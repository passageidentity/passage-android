/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package id.passage.android.api

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import id.passage.android.model.AuthResponse
import id.passage.android.model.IdTokenRequest
import id.passage.android.model.Model400Error
import id.passage.android.model.Model403Error
import id.passage.android.model.Model500Error

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import id.passage.client.infrastructure.ApiClient
import id.passage.client.infrastructure.ApiResponse
import id.passage.client.infrastructure.ClientException
import id.passage.client.infrastructure.ClientError
import id.passage.client.infrastructure.ServerException
import id.passage.client.infrastructure.ServerError
import id.passage.client.infrastructure.MultiValueMap
import id.passage.client.infrastructure.PartConfig
import id.passage.client.infrastructure.RequestConfig
import id.passage.client.infrastructure.RequestMethod
import id.passage.client.infrastructure.ResponseType
import id.passage.client.infrastructure.Success
import id.passage.client.infrastructure.toMultiValue

class OAuth2API(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://auth.passage.id/v1")
        }
    }

    /**
     * enum for parameter error
     */
     enum class Error_appleOauth2Callback(val value: kotlin.String) {
         @Json(name = "user_cancelled_authorize") userCancelledAuthorize("user_cancelled_authorize")
     }

    /**
     * Handle Apple&#39;s OAuth2 callback
     * 
     * @param appId App ID
     * @param state The state contained in the authorization request.
     * @param code A single-use authorization grant code that’s valid for five minutes. (optional)
     * @param idToken A JWT containing the user’s identity information. (optional)
     * @param user A JSON string containing the data requested in the scope property. (optional)
     * @param error The error returned by Apple. (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun appleOauth2Callback(appId: kotlin.String, state: kotlin.String, code: kotlin.String? = null, idToken: kotlin.String? = null, user: kotlin.String? = null, error: Error_appleOauth2Callback? = null) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = appleOauth2CallbackWithHttpInfo(appId = appId, state = state, code = code, idToken = idToken, user = user, error = error)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Handle Apple&#39;s OAuth2 callback
     * 
     * @param appId App ID
     * @param state The state contained in the authorization request.
     * @param code A single-use authorization grant code that’s valid for five minutes. (optional)
     * @param idToken A JWT containing the user’s identity information. (optional)
     * @param user A JSON string containing the data requested in the scope property. (optional)
     * @param error The error returned by Apple. (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun appleOauth2CallbackWithHttpInfo(appId: kotlin.String, state: kotlin.String, code: kotlin.String?, idToken: kotlin.String?, user: kotlin.String?, error: Error_appleOauth2Callback?) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = appleOauth2CallbackRequestConfig(appId = appId, state = state, code = code, idToken = idToken, user = user, error = error)

        return@withContext request<Map<String, PartConfig<*>>, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation appleOauth2Callback
     *
     * @param appId App ID
     * @param state The state contained in the authorization request.
     * @param code A single-use authorization grant code that’s valid for five minutes. (optional)
     * @param idToken A JWT containing the user’s identity information. (optional)
     * @param user A JSON string containing the data requested in the scope property. (optional)
     * @param error The error returned by Apple. (optional)
     * @return RequestConfig
     */
    fun appleOauth2CallbackRequestConfig(appId: kotlin.String, state: kotlin.String, code: kotlin.String?, idToken: kotlin.String?, user: kotlin.String?, error: Error_appleOauth2Callback?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "code" to PartConfig(body = code, headers = mutableMapOf()),
            "id_token" to PartConfig(body = idToken, headers = mutableMapOf()),
            "state" to PartConfig(body = state, headers = mutableMapOf()),
            "user" to PartConfig(body = user, headers = mutableMapOf()),
            "error" to PartConfig(body = error?.value, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/apps/{app_id}/social/oauth2_callback".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter error
     */
     enum class Error_appleOauth2CallbackDefaultDev(val value: kotlin.String) {
         @Json(name = "user_cancelled_authorize") userCancelledAuthorize("user_cancelled_authorize")
     }

    /**
     * Handle Apple&#39;s OAuth2 callback for the default developer credentials
     * 
     * @param state The state contained in the authorization request.
     * @param code A single-use authorization grant code that’s valid for five minutes. (optional)
     * @param idToken A JWT containing the user’s identity information. (optional)
     * @param user A JSON string containing the data requested in the scope property. (optional)
     * @param error The error returned by Apple. (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun appleOauth2CallbackDefaultDev(state: kotlin.String, code: kotlin.String? = null, idToken: kotlin.String? = null, user: kotlin.String? = null, error: Error_appleOauth2CallbackDefaultDev? = null) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = appleOauth2CallbackDefaultDevWithHttpInfo(state = state, code = code, idToken = idToken, user = user, error = error)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Handle Apple&#39;s OAuth2 callback for the default developer credentials
     * 
     * @param state The state contained in the authorization request.
     * @param code A single-use authorization grant code that’s valid for five minutes. (optional)
     * @param idToken A JWT containing the user’s identity information. (optional)
     * @param user A JSON string containing the data requested in the scope property. (optional)
     * @param error The error returned by Apple. (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun appleOauth2CallbackDefaultDevWithHttpInfo(state: kotlin.String, code: kotlin.String?, idToken: kotlin.String?, user: kotlin.String?, error: Error_appleOauth2CallbackDefaultDev?) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = appleOauth2CallbackDefaultDevRequestConfig(state = state, code = code, idToken = idToken, user = user, error = error)

        return@withContext request<Map<String, PartConfig<*>>, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation appleOauth2CallbackDefaultDev
     *
     * @param state The state contained in the authorization request.
     * @param code A single-use authorization grant code that’s valid for five minutes. (optional)
     * @param idToken A JWT containing the user’s identity information. (optional)
     * @param user A JSON string containing the data requested in the scope property. (optional)
     * @param error The error returned by Apple. (optional)
     * @return RequestConfig
     */
    fun appleOauth2CallbackDefaultDevRequestConfig(state: kotlin.String, code: kotlin.String?, idToken: kotlin.String?, user: kotlin.String?, error: Error_appleOauth2CallbackDefaultDev?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "code" to PartConfig(body = code, headers = mutableMapOf()),
            "id_token" to PartConfig(body = idToken, headers = mutableMapOf()),
            "state" to PartConfig(body = state, headers = mutableMapOf()),
            "user" to PartConfig(body = user, headers = mutableMapOf()),
            "error" to PartConfig(body = error?.value, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/social/oauth2_callback",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Link an existing account to an OAuth2 connection.
     * 
     * @param appId App ID
     * @param code The code given from the OAuth2 redirect
     * @param verifier The verifier the client originally sent to the OAuth2 provider
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun currentuserSocialLinkAccount(appId: kotlin.String, code: kotlin.String, verifier: kotlin.String) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = currentuserSocialLinkAccountWithHttpInfo(appId = appId, code = code, verifier = verifier)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Link an existing account to an OAuth2 connection.
     * 
     * @param appId App ID
     * @param code The code given from the OAuth2 redirect
     * @param verifier The verifier the client originally sent to the OAuth2 provider
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun currentuserSocialLinkAccountWithHttpInfo(appId: kotlin.String, code: kotlin.String, verifier: kotlin.String) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = currentuserSocialLinkAccountRequestConfig(appId = appId, code = code, verifier = verifier)

        return@withContext request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation currentuserSocialLinkAccount
     *
     * @param appId App ID
     * @param code The code given from the OAuth2 redirect
     * @param verifier The verifier the client originally sent to the OAuth2 provider
     * @return RequestConfig
     */
    fun currentuserSocialLinkAccountRequestConfig(appId: kotlin.String, code: kotlin.String, verifier: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("code", listOf(code.toString()))
                put("verifier", listOf(verifier.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/apps/{app_id}/currentuser/social/link_account".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Exchange native mobile identity token for an auth token.
     * 
     * @param appId App ID
     * @param idTokenRequest 
     * @return AuthResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun exchangeSocialIdToken(appId: kotlin.String, idTokenRequest: IdTokenRequest) : AuthResponse = withContext(Dispatchers.IO) {
        val localVarResponse = exchangeSocialIdTokenWithHttpInfo(appId = appId, idTokenRequest = idTokenRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Exchange native mobile identity token for an auth token.
     * 
     * @param appId App ID
     * @param idTokenRequest 
     * @return ApiResponse<AuthResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun exchangeSocialIdTokenWithHttpInfo(appId: kotlin.String, idTokenRequest: IdTokenRequest) : ApiResponse<AuthResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = exchangeSocialIdTokenRequestConfig(appId = appId, idTokenRequest = idTokenRequest)

        return@withContext request<IdTokenRequest, AuthResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exchangeSocialIdToken
     *
     * @param appId App ID
     * @param idTokenRequest 
     * @return RequestConfig
     */
    fun exchangeSocialIdTokenRequestConfig(appId: kotlin.String, idTokenRequest: IdTokenRequest) : RequestConfig<IdTokenRequest> {
        val localVariableBody = idTokenRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/apps/{app_id}/social/id_token".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Exchange OAuth2 connection data for an auth token.
     * 
     * @param appId App ID
     * @param code The code given from the OAuth2 redirect
     * @param verifier The verifier the client originally sent to the OAuth2 provider
     * @return AuthResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun exchangeSocialToken(appId: kotlin.String, code: kotlin.String, verifier: kotlin.String) : AuthResponse = withContext(Dispatchers.IO) {
        val localVarResponse = exchangeSocialTokenWithHttpInfo(appId = appId, code = code, verifier = verifier)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Exchange OAuth2 connection data for an auth token.
     * 
     * @param appId App ID
     * @param code The code given from the OAuth2 redirect
     * @param verifier The verifier the client originally sent to the OAuth2 provider
     * @return ApiResponse<AuthResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun exchangeSocialTokenWithHttpInfo(appId: kotlin.String, code: kotlin.String, verifier: kotlin.String) : ApiResponse<AuthResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = exchangeSocialTokenRequestConfig(appId = appId, code = code, verifier = verifier)

        return@withContext request<Unit, AuthResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exchangeSocialToken
     *
     * @param appId App ID
     * @param code The code given from the OAuth2 redirect
     * @param verifier The verifier the client originally sent to the OAuth2 provider
     * @return RequestConfig
     */
    fun exchangeSocialTokenRequestConfig(appId: kotlin.String, code: kotlin.String, verifier: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("code", listOf(code.toString()))
                put("verifier", listOf(verifier.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/apps/{app_id}/social/token".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter connectionType
     */
     enum class ConnectionType_getAuthorize(val value: kotlin.String) {
         @Json(name = "apple") apple("apple"),
         @Json(name = "github") github("github"),
         @Json(name = "google") google("google"),
         @Json(name = "passage") passage("passage")
     }

    /**
     * Kick off OAuth2 flow
     * Kick off OAuth2 flow with connection provider request params described in https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest
     * @param appId App ID
     * @param redirectUri The URL to redirect to after the OAuth2 flow is complete.
     * @param codeChallenge Code challenge.
     * @param codeChallengeMethod Code challenge method.
     * @param connectionType connection type; google, github, apple, or passage to login with
     * @param state The state to pass through to the redirect URI. (optional)
     * @param loginHint Hint to the Authorization Server about the login identifier the end-user might use to log in. (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getAuthorize(appId: kotlin.String, redirectUri: kotlin.String, codeChallenge: kotlin.String, codeChallengeMethod: kotlin.String, connectionType: ConnectionType_getAuthorize, state: kotlin.String? = null, loginHint: kotlin.String? = null) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = getAuthorizeWithHttpInfo(appId = appId, redirectUri = redirectUri, codeChallenge = codeChallenge, codeChallengeMethod = codeChallengeMethod, connectionType = connectionType, state = state, loginHint = loginHint)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Kick off OAuth2 flow
     * Kick off OAuth2 flow with connection provider request params described in https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest
     * @param appId App ID
     * @param redirectUri The URL to redirect to after the OAuth2 flow is complete.
     * @param codeChallenge Code challenge.
     * @param codeChallengeMethod Code challenge method.
     * @param connectionType connection type; google, github, apple, or passage to login with
     * @param state The state to pass through to the redirect URI. (optional)
     * @param loginHint Hint to the Authorization Server about the login identifier the end-user might use to log in. (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getAuthorizeWithHttpInfo(appId: kotlin.String, redirectUri: kotlin.String, codeChallenge: kotlin.String, codeChallengeMethod: kotlin.String, connectionType: ConnectionType_getAuthorize, state: kotlin.String?, loginHint: kotlin.String?) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getAuthorizeRequestConfig(appId = appId, redirectUri = redirectUri, codeChallenge = codeChallenge, codeChallengeMethod = codeChallengeMethod, connectionType = connectionType, state = state, loginHint = loginHint)

        return@withContext request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAuthorize
     *
     * @param appId App ID
     * @param redirectUri The URL to redirect to after the OAuth2 flow is complete.
     * @param codeChallenge Code challenge.
     * @param codeChallengeMethod Code challenge method.
     * @param connectionType connection type; google, github, apple, or passage to login with
     * @param state The state to pass through to the redirect URI. (optional)
     * @param loginHint Hint to the Authorization Server about the login identifier the end-user might use to log in. (optional)
     * @return RequestConfig
     */
    fun getAuthorizeRequestConfig(appId: kotlin.String, redirectUri: kotlin.String, codeChallenge: kotlin.String, codeChallengeMethod: kotlin.String, connectionType: ConnectionType_getAuthorize, state: kotlin.String?, loginHint: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("redirect_uri", listOf(redirectUri.toString()))
                if (state != null) {
                    put("state", listOf(state.toString()))
                }
                if (loginHint != null) {
                    put("login_hint", listOf(loginHint.toString()))
                }
                put("code_challenge", listOf(codeChallenge.toString()))
                put("code_challenge_method", listOf(codeChallengeMethod.toString()))
                put("connection_type", listOf(connectionType.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/apps/{app_id}/social/authorize".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter error
     */
     enum class Error_oauth2Callback(val value: kotlin.String) {
         @Json(name = "interaction_required") interactionRequired("interaction_required"),
         @Json(name = "login_required") loginRequired("login_required"),
         @Json(name = "account_selection_required") accountSelectionRequired("account_selection_required"),
         @Json(name = "consent_required") consentRequired("consent_required"),
         @Json(name = "invalid_request_uri") invalidRequestUri("invalid_request_uri"),
         @Json(name = "invalid_request_object") invalidRequestObject("invalid_request_object"),
         @Json(name = "request_not_supported") requestNotSupported("request_not_supported"),
         @Json(name = "request_uri_not_supported") requestUriNotSupported("request_uri_not_supported"),
         @Json(name = "registration_not_supported") registrationNotSupported("registration_not_supported")
     }

    /**
     * Handle OAuth2 callback
     * 
     * @param appId App ID
     * @param code The authorization code returned by the OAuth2 provider.
     * @param state The state returned by the OAuth2 provider. (optional)
     * @param error The error returned by the OAuth2 provider. (optional)
     * @param errorDescription The error description returned by the OAuth2 provider. (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun oauth2Callback(appId: kotlin.String, code: kotlin.String, state: kotlin.String? = null, error: Error_oauth2Callback? = null, errorDescription: kotlin.String? = null) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = oauth2CallbackWithHttpInfo(appId = appId, code = code, state = state, error = error, errorDescription = errorDescription)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Handle OAuth2 callback
     * 
     * @param appId App ID
     * @param code The authorization code returned by the OAuth2 provider.
     * @param state The state returned by the OAuth2 provider. (optional)
     * @param error The error returned by the OAuth2 provider. (optional)
     * @param errorDescription The error description returned by the OAuth2 provider. (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun oauth2CallbackWithHttpInfo(appId: kotlin.String, code: kotlin.String, state: kotlin.String?, error: Error_oauth2Callback?, errorDescription: kotlin.String?) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = oauth2CallbackRequestConfig(appId = appId, code = code, state = state, error = error, errorDescription = errorDescription)

        return@withContext request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation oauth2Callback
     *
     * @param appId App ID
     * @param code The authorization code returned by the OAuth2 provider.
     * @param state The state returned by the OAuth2 provider. (optional)
     * @param error The error returned by the OAuth2 provider. (optional)
     * @param errorDescription The error description returned by the OAuth2 provider. (optional)
     * @return RequestConfig
     */
    fun oauth2CallbackRequestConfig(appId: kotlin.String, code: kotlin.String, state: kotlin.String?, error: Error_oauth2Callback?, errorDescription: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("code", listOf(code.toString()))
                if (state != null) {
                    put("state", listOf(state.toString()))
                }
                if (error != null) {
                    put("error", listOf(error.toString()))
                }
                if (errorDescription != null) {
                    put("error_description", listOf(errorDescription.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/apps/{app_id}/social/oauth2_callback".replace("{"+"app_id"+"}", encodeURIComponent(appId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter error
     */
     enum class Error_oauth2CallbackDefaultDev(val value: kotlin.String) {
         @Json(name = "interaction_required") interactionRequired("interaction_required"),
         @Json(name = "login_required") loginRequired("login_required"),
         @Json(name = "account_selection_required") accountSelectionRequired("account_selection_required"),
         @Json(name = "consent_required") consentRequired("consent_required"),
         @Json(name = "invalid_request_uri") invalidRequestUri("invalid_request_uri"),
         @Json(name = "invalid_request_object") invalidRequestObject("invalid_request_object"),
         @Json(name = "request_not_supported") requestNotSupported("request_not_supported"),
         @Json(name = "request_uri_not_supported") requestUriNotSupported("request_uri_not_supported"),
         @Json(name = "registration_not_supported") registrationNotSupported("registration_not_supported")
     }

    /**
     * Handle OAuth2 callback for the default developer credentials
     * 
     * @param code The authorization code returned by the OAuth2 provider.
     * @param state The state returned by the OAuth2 provider. (optional)
     * @param error The error returned by the OAuth2 provider. (optional)
     * @param errorDescription The error description returned by the OAuth2 provider. (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun oauth2CallbackDefaultDev(code: kotlin.String, state: kotlin.String? = null, error: Error_oauth2CallbackDefaultDev? = null, errorDescription: kotlin.String? = null) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = oauth2CallbackDefaultDevWithHttpInfo(code = code, state = state, error = error, errorDescription = errorDescription)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Handle OAuth2 callback for the default developer credentials
     * 
     * @param code The authorization code returned by the OAuth2 provider.
     * @param state The state returned by the OAuth2 provider. (optional)
     * @param error The error returned by the OAuth2 provider. (optional)
     * @param errorDescription The error description returned by the OAuth2 provider. (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun oauth2CallbackDefaultDevWithHttpInfo(code: kotlin.String, state: kotlin.String?, error: Error_oauth2CallbackDefaultDev?, errorDescription: kotlin.String?) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = oauth2CallbackDefaultDevRequestConfig(code = code, state = state, error = error, errorDescription = errorDescription)

        return@withContext request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation oauth2CallbackDefaultDev
     *
     * @param code The authorization code returned by the OAuth2 provider.
     * @param state The state returned by the OAuth2 provider. (optional)
     * @param error The error returned by the OAuth2 provider. (optional)
     * @param errorDescription The error description returned by the OAuth2 provider. (optional)
     * @return RequestConfig
     */
    fun oauth2CallbackDefaultDevRequestConfig(code: kotlin.String, state: kotlin.String?, error: Error_oauth2CallbackDefaultDev?, errorDescription: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("code", listOf(code.toString()))
                if (state != null) {
                    put("state", listOf(state.toString()))
                }
                if (error != null) {
                    put("error", listOf(error.toString()))
                }
                if (errorDescription != null) {
                    put("error_description", listOf(errorDescription.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/social/oauth2_callback",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
